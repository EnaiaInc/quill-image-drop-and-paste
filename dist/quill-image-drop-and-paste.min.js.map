{"version":3,"file":"quill-image-drop-and-paste.min.js","sources":["../src/utils.ts","../src/ImageData.ts","../src/ImageDropAndPaste.ts"],"sourcesContent":["export default {\n  /* detect the giving url is a image\n   */\n  urlIsImage(url: string, abortTimeout = 3000): Promise<boolean> {\n    if (!this.validURL(url)) {\n      return Promise.reject(false);\n    }\n    if (/\\.(jpeg|jpg|gif|png|webp|tiff|bmp)$/.test(url)) {\n      return Promise.resolve(true);\n    }\n    return new Promise((resolve, reject) => {\n      let timer: any = undefined;\n      const img = new Image();\n      img.onerror = img.onabort = () => {\n        clearTimeout(timer);\n        reject(false);\n      };\n      img.onload = () => {\n        clearTimeout(timer);\n        resolve(true);\n      };\n      timer = setTimeout(() => {\n        img.src = '//!/an/invalid.jpg';\n        reject(false);\n      }, abortTimeout);\n      img.src = url;\n    });\n  },\n  /* check string is a valid url\n   */\n  validURL(str: string): boolean {\n    try {\n      return Boolean(new URL(str));\n    } catch (e) {\n      return false;\n    }\n  },\n  /* check the giving string is a html text\n   */\n  isRichText(clipboardDataItems: DataTransferItemList): boolean {\n    let isHtml = false;\n    Array.prototype.forEach.call(clipboardDataItems, (item) => {\n      if (item.type.match(/^text\\/html$/i)) {\n        isHtml = true;\n      }\n    });\n    return isHtml;\n  },\n  /* resolve dataUrl to base64 string\n   */\n  resolveDataUrl(dataUrl: string | ArrayBuffer): string {\n    let str = '';\n    if (typeof dataUrl === 'string') {\n      str = dataUrl;\n    } else if (dataUrl instanceof ArrayBuffer) {\n      str = this.arrayBufferToBase64Url(dataUrl);\n    }\n    return str;\n  },\n  /* generate array buffer from binary string\n   */\n  binaryStringToArrayBuffer(binary: string): ArrayBuffer {\n    const len = binary.length;\n    const buffer = new ArrayBuffer(len);\n    const arr = new Uint8Array(buffer);\n    let i = -1;\n    while (++i < len) arr[i] = binary.charCodeAt(i);\n    return buffer;\n  },\n  /* generate base64 string from array buffer\n   */\n  arrayBufferToBase64Url(arrayBuffer: ArrayBuffer): string {\n    return btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\n  },\n  /* copy text - make text store in the clipboard\n   */\n  copyText(content: string, target = document.body): boolean {\n    const element = document.createElement('textarea');\n    const previouslyFocusedElement = document.activeElement;\n    element.value = content;\n    // Prevent keyboard from showing on mobile\n    element.setAttribute('readonly', '');\n    element.style.position = 'absolute';\n    element.style.left = '-9999px';\n    element.style.fontSize = '12pt'; // Prevent zooming on iOS\n    const selection = document.getSelection();\n    let originalRange: boolean | Range = false;\n    if (selection && selection.rangeCount > 0) {\n      originalRange = selection.getRangeAt(0);\n    }\n    target.append(element);\n    element.select();\n    // Explicit selection workaround for iOS\n    element.selectionStart = 0;\n    element.selectionEnd = content.length;\n    let isSuccess = false;\n    try {\n      isSuccess = document.execCommand('copy');\n    } catch {}\n    element.remove();\n    if (selection && originalRange) {\n      selection.removeAllRanges();\n      selection.addRange(originalRange);\n    }\n    // Get the focus back on the previously focused element, if any\n    if (previouslyFocusedElement) {\n      (previouslyFocusedElement as HTMLElement).focus();\n    }\n    return isSuccess;\n  },\n  /* check the type of specify target\n   */\n  isType(target: any, type: string): boolean {\n    return Object.prototype.toString.call(target) === `[object ${type}]`;\n  },\n};\n","import utils from './utils';\nimport { IImageDataMinifyOption } from './index.d';\n\nabstract class QuillImageData {\n  public dataUrl;\n  public type;\n  public constructor(dataUrl, type) {\n    this.dataUrl = dataUrl;\n    this.type = type;\n  }\n  public abstract minify(option: IImageDataMinifyOption);\n  public abstract toFile(filename: string);\n  public abstract toBlob();\n}\n\nclass ImageData extends QuillImageData {\n  dataUrl: string | ArrayBuffer;\n  type: string;\n\n  constructor(dataUrl: string | ArrayBuffer, type: string) {\n    super(dataUrl, type);\n    this.dataUrl = dataUrl;\n    this.type = type;\n  }\n\n  /* minify the image\n   */\n  public minify(option: IImageDataMinifyOption): Promise<ImageData | { message: string }> {\n    return new Promise((resolve, reject) => {\n      const maxWidth = option.maxWidth || 800;\n      const maxHeight = option.maxHeight || 800;\n      const quality = option.quality || 0.8;\n      if (!this.dataUrl) {\n        return reject({\n          message: '[error] QuillImageDropAndPaste: Fail to minify the image, dataUrl should not be empty.',\n        });\n      }\n      const image = new Image();\n      image.onload = () => {\n        const width = image.width;\n        const height = image.height;\n        if (width > height) {\n          if (width > maxWidth) {\n            image.height = (height * maxWidth) / width;\n            image.width = maxWidth;\n          }\n        } else {\n          if (height > maxHeight) {\n            image.width = (width * maxHeight) / height;\n            image.height = maxHeight;\n          }\n        }\n        const canvas = document.createElement('canvas');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const ctx = canvas.getContext('2d');\n        if (ctx) {\n          ctx.drawImage(image, 0, 0, image.width, image.height);\n          const canvasType = this.type || 'image/png';\n          const canvasDataUrl = canvas.toDataURL(canvasType, quality);\n          resolve(new ImageData(canvasDataUrl, canvasType));\n        } else {\n          reject({\n            message: '[error] QuillImageDropAndPaste: Fail to minify the image, create canvas context failure.',\n          });\n        }\n      };\n      image.src = utils.resolveDataUrl(this.dataUrl);\n    });\n  }\n\n  /* convert blob to file\n   */\n  public toFile(filename: string): File | null {\n    if (!window.File) {\n      console.error('[error] QuillImageDropAndPaste: Your browser didnot support File API.');\n      return null;\n    }\n    return new File([this.toBlob()], filename, { type: this.type });\n  }\n\n  /* convert dataURL to blob\n   */\n  public toBlob(): Blob {\n    const base64 = utils.resolveDataUrl(this.dataUrl).replace(/^[^,]+,/, '');\n    const buff = utils.binaryStringToArrayBuffer(atob(base64));\n    return this.createBlob([buff], { type: this.type });\n  }\n\n  /* create blob\n   */\n  private createBlob(parts: ArrayBuffer[], properties: string | { type?: string } | undefined): Blob {\n    if (!properties) properties = {};\n    if (typeof properties === 'string') properties = { type: properties };\n    try {\n      return new Blob(parts, properties);\n    } catch (e) {\n      if (e.name !== 'TypeError') throw e;\n      const Builder =\n        'BlobBuilder' in window\n          ? (window as any).BlobBuilder\n          : 'MSBlobBuilder' in window\n          ? (window as any).MSBlobBuilder\n          : 'MozBlobBuilder' in window\n          ? (window as any).MozBlobBuilder\n          : (window as any).WebKitBlobBuilder;\n      const builder = new Builder();\n      for (let i = 0; i < parts.length; i++) builder.append(parts[i]);\n      return builder.getBlob(properties.type) as Blob;\n    }\n  }\n}\n\nexport default ImageData;\n","import utils from './utils';\nimport Quill from 'quill';\nimport ImageData from './ImageData';\n\ninterface IImageDropAndPasteOption {\n  handler?: (dataUrl: string | ArrayBuffer, type?: string, imageData?: ImageData) => void;\n}\n\nabstract class QuillImageDropAndPaste {\n  static ImageData;\n  public quill;\n  public option: IImageDropAndPasteOption;\n  public constructor(quill: Quill, option: IImageDropAndPasteOption) {\n    this.quill = quill;\n    this.option = option;\n  }\n  protected abstract handleDrop(e: DragEvent);\n  protected abstract handlePaste(e: ClipboardEvent);\n  protected abstract readFiles(\n    files: DataTransferItemList | FileList,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent,\n  );\n  protected abstract handleDataTransfer(\n    file: DataTransferItem,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent,\n  );\n  protected abstract handleDroppedFile(\n    file: File,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent,\n  );\n  protected abstract insert(content: string, type: string);\n}\n\nclass ImageDropAndPaste extends QuillImageDropAndPaste {\n  static ImageData = ImageData;\n  quill: Quill;\n  option: IImageDropAndPasteOption;\n\n  constructor(quill: Quill, option: IImageDropAndPasteOption) {\n    super(quill, option);\n    this.quill = quill;\n    this.option = option;\n    this.handleDrop = this.handleDrop.bind(this);\n    this.handlePaste = this.handlePaste.bind(this);\n    this.insert = this.insert.bind(this);\n    this.quill.root.addEventListener('drop', this.handleDrop, false);\n    this.quill.root.addEventListener('paste', this.handlePaste, false);\n  }\n\n  /* handle image drop event\n   */\n  handleDrop(e: DragEvent): void {\n    e.preventDefault();\n    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {\n      if (document.caretRangeFromPoint) {\n        const selection = document.getSelection();\n        const range = document.caretRangeFromPoint(e.clientX, e.clientY);\n        if (selection && range) {\n          selection.setBaseAndExtent(range.startContainer, range.startOffset, range.startContainer, range.startOffset);\n        }\n      }\n      this.readFiles(\n        e.dataTransfer.files,\n        (dataUrl, type) => {\n          type = type || 'image/png';\n          if (typeof this.option.handler === 'function') {\n            this.option.handler.call(this, dataUrl, type, new ImageData(dataUrl, type));\n          } else {\n            this.insert.call(this, utils.resolveDataUrl(dataUrl), type);\n          }\n        },\n        e,\n      );\n    }\n  }\n\n  /* handle image paste event\n   */\n  handlePaste(e: ClipboardEvent): void {\n    if (e.clipboardData && e.clipboardData.items && e.clipboardData.items.length) {\n      if (utils.isRichText(e.clipboardData.items)) return;\n      this.readFiles(\n        e.clipboardData.items,\n        (dataUrl: string | ArrayBuffer, type?: string) => {\n          type = type || 'image/png';\n          if (typeof this.option.handler === 'function') {\n            this.option.handler.call(this, dataUrl, type, new ImageData(dataUrl, type));\n          } else {\n            this.insert(utils.resolveDataUrl(dataUrl), 'image');\n          }\n        },\n        e,\n      );\n    }\n  }\n\n  /* read the files\n   */\n  readFiles(\n    files: DataTransferItemList | FileList,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent,\n  ): void {\n    Array.prototype.forEach.call(files, (file: DataTransferItem | File) => {\n      if (utils.isType(file, 'DataTransferItem')) {\n        this.handleDataTransfer(file as DataTransferItem, callback, e);\n      } else if (file instanceof File) {\n        this.handleDroppedFile(file, callback, e);\n      }\n    });\n  }\n\n  /* handle the pasted data\n   */\n  handleDataTransfer(\n    file: DataTransferItem,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent,\n  ): void {\n    const that = this;\n    const type = file.type;\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\n      e.preventDefault();\n      const reader = new FileReader();\n      reader.onload = (e: ProgressEvent<FileReader>) => {\n        if (e.target && e.target.result) {\n          callback(e.target.result, type);\n        }\n      };\n      const blob = file.getAsFile ? file.getAsFile() : file;\n      if (blob instanceof Blob) reader.readAsDataURL(blob);\n    } else if (type.match(/^text\\/plain$/i)) {\n      e.preventDefault();\n      file.getAsString((s) => {\n        utils\n          .urlIsImage(s)\n          .then(() => {\n            that.insert(s, 'image');\n          })\n          .catch(() => {\n            that.insert(s, 'text');\n          });\n      });\n    }\n  }\n\n  /* handle the dropped data\n   */\n  handleDroppedFile(\n    file: File,\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\n    e: ClipboardEvent | DragEvent,\n  ): void {\n    const type = file.type;\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\n      e.preventDefault();\n      const reader = new FileReader();\n      reader.onload = (e: ProgressEvent<FileReader>) => {\n        if (e.target && e.target.result) {\n          callback(e.target.result, type);\n        }\n      };\n      reader.readAsDataURL(file);\n    }\n  }\n\n  /* insert into the editor\n   */\n  insert(content: string, type: string): void {\n    let index: number | undefined = (this.quill.getSelection(true) || {}).index;\n    if (index === undefined || index < 0) index = this.quill.getLength();\n    let _index: any;\n    if (type === 'image') {\n      _index = index + 1;\n      this.quill.insertEmbed(index, type, content, 'user');\n    } else if (type === 'text') {\n      _index = index + content.length;\n      this.quill.insertText(index, content, 'user');\n    }\n    setTimeout(() => {\n      this.quill.setSelection(_index);\n    });\n  }\n}\n\n(window as any).QuillImageDropAndPaste = ImageDropAndPaste;\nif ('Quill' in window) {\n  (window as any).Quill.register('modules/imageDropAndPaste', ImageDropAndPaste);\n}\n\nexport default ImageDropAndPaste;\n"],"names":["urlIsImage","url","abortTimeout","this","validURL","test","Promise","resolve","reject","timer","img","Image","onerror","onabort","clearTimeout","onload","setTimeout","src","str","Boolean","URL","e","isRichText","clipboardDataItems","isHtml","Array","prototype","forEach","call","item","type","match","resolveDataUrl","dataUrl","ArrayBuffer","arrayBufferToBase64Url","binaryStringToArrayBuffer","binary","len","length","buffer","arr","Uint8Array","i","charCodeAt","arrayBuffer","btoa","String","fromCharCode","copyText","content","target","document","body","element","createElement","previouslyFocusedElement","activeElement","value","setAttribute","style","position","left","fontSize","selection","getSelection","originalRange","rangeCount","getRangeAt","append","select","selectionStart","selectionEnd","isSuccess","execCommand","remove","removeAllRanges","addRange","focus","isType","Object","toString","ImageData","constructor","super","minify","option","maxWidth","maxHeight","quality","message","image","width","height","canvas","ctx","getContext","drawImage","canvasType","canvasDataUrl","toDataURL","utils","toFile","filename","window","File","toBlob","console","error","base64","replace","buff","atob","createBlob","parts","properties","Blob","name","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","getBlob","ImageDropAndPaste","quill","handleDrop","bind","handlePaste","insert","root","addEventListener","preventDefault","dataTransfer","files","caretRangeFromPoint","range","clientX","clientY","setBaseAndExtent","startContainer","startOffset","readFiles","handler","clipboardData","items","callback","file","handleDataTransfer","handleDroppedFile","that","reader","FileReader","result","blob","getAsFile","readAsDataURL","getAsString","s","then","catch","_index","index","undefined","getLength","insertEmbed","insertText","setSelection","QuillImageDropAndPaste","Quill","register"],"mappings":"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"}