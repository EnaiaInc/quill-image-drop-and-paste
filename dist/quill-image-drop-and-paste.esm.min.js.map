{"version":3,"file":"quill-image-drop-and-paste.esm.min.js","sources":["../src/utils.ts","../src/ImageData.ts","../src/ImageDropAndPaste.ts"],"sourcesContent":["export default {\r\n  /* generate a filename\r\n   */\r\n  generateFilename(): string {\r\n    return btoa(String(Math.random() * 1e6) + String(+new Date())).replace(\r\n      '=',\r\n      ''\r\n    )\r\n  },\r\n  /* detect the giving url is a image\r\n   */\r\n  urlIsImage(url: string, abortTimeout = 3000): Promise<boolean> {\r\n    if (!this.validURL(url)) {\r\n      return Promise.reject(false)\r\n    }\r\n    if (/\\.(jpeg|jpg|gif|png|webp|tiff|bmp)$/.test(url)) {\r\n      return Promise.resolve(true)\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      let timer: any = undefined\r\n      const img = new Image()\r\n      img.onerror = img.onabort = () => {\r\n        clearTimeout(timer)\r\n        reject(false)\r\n      }\r\n      img.onload = () => {\r\n        clearTimeout(timer)\r\n        resolve(true)\r\n      }\r\n      timer = setTimeout(() => {\r\n        img.src = '//!/an/invalid.jpg'\r\n        reject(false)\r\n      }, abortTimeout)\r\n      img.src = url\r\n    })\r\n  },\r\n  urlIsImageDataUrl(url: string): boolean {\r\n    return /^data:image\\/\\w+;base64,/.test(url)\r\n  },\r\n  /* check string is a valid url\r\n   */\r\n  validURL(str: string): boolean {\r\n    try {\r\n      return Boolean(new URL(str))\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  },\r\n  /* check the giving string is a html text\r\n   */\r\n  isRichText(clipboardDataItems: DataTransferItemList): boolean {\r\n    let hasHtml = false\r\n    let hasImage = false\r\n    Array.prototype.forEach.call(clipboardDataItems, (item) => {\r\n      console.log(item.kind, item.type)\r\n      if (item.kind === 'string' && item.type.match(/^text\\/html$/i)) {\r\n        hasHtml = true\r\n      }\r\n      if (item.kind === 'file' && item.type.match(/^image\\/\\w+$/i)) {\r\n        hasImage = true\r\n      }\r\n    })\r\n    return hasHtml && !hasImage\r\n  },\r\n  /* resolve dataUrl to base64 string\r\n   */\r\n  resolveDataUrl(dataUrl: string | ArrayBuffer, type: string): string {\r\n    let str = ''\r\n    if (typeof dataUrl === 'string') {\r\n      str = dataUrl\r\n    } else if (dataUrl instanceof ArrayBuffer) {\r\n      str = this.arrayBufferToBase64Url(dataUrl, type)\r\n    }\r\n    return str\r\n  },\r\n  /* generate array buffer from binary string\r\n   */\r\n  binaryStringToArrayBuffer(binary: string): ArrayBuffer {\r\n    const len = binary.length\r\n    const buffer = new ArrayBuffer(len)\r\n    const arr = new Uint8Array(buffer)\r\n    let i = -1\r\n    while (++i < len) arr[i] = binary.charCodeAt(i)\r\n    return buffer\r\n  },\r\n  /* generate base64 string from array buffer\r\n   */\r\n  arrayBufferToBase64Url(arrayBuffer: ArrayBuffer, type: string): string {\r\n    return (\r\n      `data:${type};base64,` +\r\n      btoa(\r\n        new Uint8Array(arrayBuffer).reduce(\r\n          (acc: string, byte: number) => acc + String.fromCharCode(byte),\r\n          ''\r\n        )\r\n      )\r\n    )\r\n  },\r\n  /* copy text - make text store in the clipboard\r\n   */\r\n  copyText(content: string, target = document.body): boolean {\r\n    const element = document.createElement('textarea')\r\n    const previouslyFocusedElement = document.activeElement\r\n    element.value = content\r\n    // Prevent keyboard from showing on mobile\r\n    element.setAttribute('readonly', '')\r\n    element.style.position = 'absolute'\r\n    element.style.left = '-9999px'\r\n    element.style.fontSize = '12pt' // Prevent zooming on iOS\r\n    const selection = document.getSelection()\r\n    let originalRange: boolean | Range = false\r\n    if (selection && selection.rangeCount > 0) {\r\n      originalRange = selection.getRangeAt(0)\r\n    }\r\n    target.append(element)\r\n    element.select()\r\n    // Explicit selection workaround for iOS\r\n    element.selectionStart = 0\r\n    element.selectionEnd = content.length\r\n    let isSuccess = false\r\n    try {\r\n      isSuccess = document.execCommand('copy')\r\n      // eslint-disable-next-line no-empty\r\n    } catch {}\r\n    element.remove()\r\n    if (selection && originalRange) {\r\n      selection.removeAllRanges()\r\n      selection.addRange(originalRange)\r\n    }\r\n    // Get the focus back on the previously focused element, if any\r\n    if (previouslyFocusedElement) {\r\n      ;(previouslyFocusedElement as HTMLElement).focus()\r\n    }\r\n    return isSuccess\r\n  },\r\n  /* check the type of specify target\r\n   */\r\n  isType(target: any, type: string): boolean {\r\n    return Object.prototype.toString.call(target) === `[object ${type}]`\r\n  },\r\n}\r\n","import utils from './utils'\r\nimport { IImageDataMinifyOption } from './index.d'\r\n\r\nabstract class QuillImageData {\r\n  public dataUrl: string | ArrayBuffer\r\n  public type: string\r\n  public name: string\r\n  public constructor(\r\n    dataUrl: string | ArrayBuffer,\r\n    type: string,\r\n    name?: string\r\n  ) {\r\n    this.dataUrl = dataUrl\r\n    this.type = type\r\n    this.name = name || ''\r\n  }\r\n  public abstract minify(option: IImageDataMinifyOption)\r\n  public abstract toFile(filename?: string)\r\n  public abstract toBlob()\r\n}\r\n\r\nclass ImageData extends QuillImageData {\r\n  dataUrl: string | ArrayBuffer\r\n  type: string\r\n  name: string\r\n\r\n  constructor(dataUrl: string | ArrayBuffer, type: string, name?: string) {\r\n    super(dataUrl, type, name)\r\n    this.dataUrl = dataUrl\r\n    this.type = type\r\n    this.name = name || `${utils.generateFilename()}.${this.getSuffix()}`\r\n  }\r\n\r\n  /* minify the image\r\n   */\r\n  public minify(\r\n    option: IImageDataMinifyOption\r\n  ): Promise<ImageData | { message: string }> {\r\n    return new Promise((resolve, reject) => {\r\n      const maxWidth = option.maxWidth || 800\r\n      const maxHeight = option.maxHeight || 800\r\n      const quality = option.quality || 0.8\r\n      if (!this.dataUrl) {\r\n        return reject({\r\n          message:\r\n            '[error] QuillImageDropAndPaste: Fail to minify the image, dataUrl should not be empty.',\r\n        })\r\n      }\r\n      const image = new Image()\r\n      image.onload = () => {\r\n        const width = image.width\r\n        const height = image.height\r\n        if (width > height) {\r\n          if (width > maxWidth) {\r\n            image.height = (height * maxWidth) / width\r\n            image.width = maxWidth\r\n          }\r\n        } else {\r\n          if (height > maxHeight) {\r\n            image.width = (width * maxHeight) / height\r\n            image.height = maxHeight\r\n          }\r\n        }\r\n        const canvas = document.createElement('canvas')\r\n        canvas.width = image.width\r\n        canvas.height = image.height\r\n        const ctx = canvas.getContext('2d')\r\n        if (ctx) {\r\n          ctx.drawImage(image, 0, 0, image.width, image.height)\r\n          const canvasType = this.type || 'image/png'\r\n          const canvasDataUrl = canvas.toDataURL(canvasType, quality)\r\n          resolve(new ImageData(canvasDataUrl, canvasType, this.name))\r\n        } else {\r\n          reject({\r\n            message:\r\n              '[error] QuillImageDropAndPaste: Fail to minify the image, create canvas context failure.',\r\n          })\r\n        }\r\n      }\r\n      image.src = utils.resolveDataUrl(this.dataUrl, this.type)\r\n    })\r\n  }\r\n\r\n  /* convert blob to file\r\n   */\r\n  public toFile(filename?: string): File | null {\r\n    filename = filename || this.name\r\n    if (!window.File) {\r\n      console.error(\r\n        '[error] QuillImageDropAndPaste: Your browser didnot support File API.'\r\n      )\r\n      return null\r\n    }\r\n    return new File([this.toBlob()], filename, { type: this.type })\r\n  }\r\n\r\n  /* convert dataURL to blob\r\n   */\r\n  public toBlob(): Blob {\r\n    const base64 = utils\r\n      .resolveDataUrl(this.dataUrl, this.type)\r\n      .replace(/^[^,]+,/, '')\r\n    const buff = utils.binaryStringToArrayBuffer(atob(base64))\r\n    return this.createBlob([buff], { type: this.type })\r\n  }\r\n\r\n  /* create blob\r\n   */\r\n  private createBlob(\r\n    parts: ArrayBuffer[],\r\n    properties: string | { type?: string } | undefined\r\n  ): Blob {\r\n    if (!properties) properties = {}\r\n    if (typeof properties === 'string') properties = { type: properties }\r\n    try {\r\n      return new Blob(parts, properties)\r\n    } catch (e: any) {\r\n      if (e.name !== 'TypeError') throw e\r\n      const Builder =\r\n        'BlobBuilder' in window\r\n          ? (window as any).BlobBuilder\r\n          : 'MSBlobBuilder' in window\r\n          ? (window as any).MSBlobBuilder\r\n          : 'MozBlobBuilder' in window\r\n          ? (window as any).MozBlobBuilder\r\n          : (window as any).WebKitBlobBuilder\r\n      const builder = new Builder()\r\n      for (let i = 0; i < parts.length; i++) builder.append(parts[i])\r\n      return builder.getBlob(properties.type) as Blob\r\n    }\r\n  }\r\n\r\n  private getSuffix(): string {\r\n    const matched = this.type.match(/^image\\/(\\w+)$/)\r\n    const suffix = matched ? matched[1] : 'png'\r\n    return suffix\r\n  }\r\n}\r\n\r\nexport default ImageData\r\n","import utils from './utils'\r\nimport Quill from 'quill'\r\nimport ImageData from './ImageData'\r\ninterface IImageDropAndPasteOption {\r\n  handler?: (\r\n    dataUrl: string | ArrayBuffer,\r\n    type?: string,\r\n    imageData?: ImageData\r\n  ) => void\r\n}\r\n\r\nabstract class QuillImageDropAndPaste {\r\n  static ImageData\r\n  public quill\r\n  public option: IImageDropAndPasteOption\r\n  public constructor(quill: Quill, option: IImageDropAndPasteOption) {\r\n    this.quill = quill\r\n    this.option = option\r\n  }\r\n  protected abstract handleDrop(e: DragEvent)\r\n  protected abstract handlePaste(e: ClipboardEvent)\r\n  protected abstract readFiles(\r\n    files: DataTransferItemList | FileList,\r\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\r\n    e: ClipboardEvent | DragEvent\r\n  )\r\n  protected abstract handleDataTransfer(\r\n    file: DataTransferItem,\r\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\r\n    e: ClipboardEvent | DragEvent\r\n  )\r\n  protected abstract handleDroppedFile(\r\n    file: File,\r\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\r\n    e: ClipboardEvent | DragEvent\r\n  )\r\n  protected abstract insert(content: string, type: string)\r\n  protected abstract getIndex()\r\n}\r\n\r\nclass ImageDropAndPaste extends QuillImageDropAndPaste {\r\n  static ImageData = ImageData\r\n  quill: Quill\r\n  option: IImageDropAndPasteOption\r\n\r\n  constructor(quill: Quill, option: IImageDropAndPasteOption) {\r\n    super(quill, option)\r\n    this.quill = quill\r\n    this.option = option\r\n    this.handleDrop = this.handleDrop.bind(this)\r\n    this.handlePaste = this.handlePaste.bind(this)\r\n    this.insert = this.insert.bind(this)\r\n    this.quill.root.addEventListener('drop', this.handleDrop, false)\r\n    this.quill.root.addEventListener('paste', this.handlePaste, false)\r\n  }\r\n\r\n  /* handle image drop event\r\n   */\r\n  handleDrop(e: DragEvent): void {\r\n    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {\r\n      e.preventDefault()\r\n      if (document.caretRangeFromPoint) {\r\n        const selection = document.getSelection()\r\n        const range = document.caretRangeFromPoint(e.clientX, e.clientY)\r\n        if (selection && range) {\r\n          selection.setBaseAndExtent(\r\n            range.startContainer,\r\n            range.startOffset,\r\n            range.startContainer,\r\n            range.startOffset\r\n          )\r\n        }\r\n      }\r\n      this.readFiles(\r\n        e.dataTransfer.files,\r\n        (dataUrl: string | ArrayBuffer, type = 'image/png', name?: string) => {\r\n          if (typeof this.option.handler === 'function') {\r\n            this.option.handler.call(\r\n              this,\r\n              dataUrl,\r\n              type,\r\n              new ImageData(dataUrl, type, name)\r\n            )\r\n          } else {\r\n            this.insert.call(this, utils.resolveDataUrl(dataUrl, type), type)\r\n          }\r\n        },\r\n        e\r\n      )\r\n    }\r\n  }\r\n\r\n  /* handle image paste event\r\n   */\r\n  handlePaste(e: ClipboardEvent): void {\r\n    if (\r\n      e.clipboardData &&\r\n      e.clipboardData.items &&\r\n      e.clipboardData.items.length\r\n    ) {\r\n      if (utils.isRichText(e.clipboardData.items)) return\r\n      this.readFiles(\r\n        e.clipboardData.items,\r\n        (dataUrl: string | ArrayBuffer, type = 'image/png') => {\r\n          if (typeof this.option.handler === 'function') {\r\n            this.option.handler.call(\r\n              this,\r\n              dataUrl,\r\n              type,\r\n              new ImageData(dataUrl, type)\r\n            )\r\n          } else {\r\n            this.insert(utils.resolveDataUrl(dataUrl, type), 'image')\r\n          }\r\n        },\r\n        e\r\n      )\r\n    }\r\n  }\r\n\r\n  /* read the files\r\n   */\r\n  readFiles(\r\n    files: DataTransferItemList | FileList,\r\n    callback: (\r\n      dataUrl: string | ArrayBuffer,\r\n      type: string,\r\n      name?: string\r\n    ) => void,\r\n    e: ClipboardEvent | DragEvent\r\n  ): void {\r\n    Array.prototype.forEach.call(files, (file: DataTransferItem | File) => {\r\n      if (utils.isType(file, 'DataTransferItem')) {\r\n        this.handleDataTransfer(file as DataTransferItem, callback, e)\r\n      } else if (file instanceof File) {\r\n        this.handleDroppedFile(file, callback, e)\r\n      }\r\n    })\r\n  }\r\n\r\n  /* handle the pasted data\r\n   */\r\n  handleDataTransfer(\r\n    file: DataTransferItem,\r\n    callback: (\r\n      dataUrl: string | ArrayBuffer,\r\n      type: string,\r\n      name?: string\r\n    ) => void,\r\n    e: ClipboardEvent | DragEvent\r\n  ): void {\r\n    const that = this\r\n    const { type } = file\r\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\r\n      e.preventDefault()\r\n      const reader = new FileReader()\r\n      reader.onload = (e: ProgressEvent<FileReader>) => {\r\n        if (e.target && e.target.result) {\r\n          callback(e.target.result, type)\r\n        }\r\n      }\r\n      const blob = file.getAsFile ? file.getAsFile() : file\r\n      if (blob instanceof Blob) reader.readAsDataURL(blob)\r\n    } else if (type.match(/^text\\/plain$/i)) {\r\n      file.getAsString((s) => {\r\n        // Don't preventDefault here, because there might be clipboard matchers need to be triggered\r\n        // see https://github.com/chenjuneking/quill-image-drop-and-paste/issues/37\r\n        this.quill.disable()\r\n        const i = this.getIndex()\r\n        utils\r\n          .urlIsImage(s)\r\n          .then(() => {\r\n            // The pasted plain text is an image\r\n            if (utils.urlIsImageDataUrl(s)) {\r\n              // If the url is a dataUrl, just fire the callback\r\n              const matched = s.match(/^data:(image\\/\\w+);base64,/)\r\n              const t = matched ? matched[1] : 'image/png'\r\n              callback(s, t)\r\n              this.quill.enable()\r\n              this.quill.setSelection(i as any)\r\n            } else {\r\n              // If the url isn't a dataUrl, just insert into the editor\r\n              setTimeout(() => {\r\n                this.quill.enable()\r\n                that.insert(s, 'image', i)\r\n              })\r\n            }\r\n          })\r\n          .catch(() => {\r\n            this.quill.enable()\r\n          })\r\n      })\r\n    }\r\n  }\r\n\r\n  /* handle the dropped data\r\n   */\r\n  handleDroppedFile(\r\n    file: File,\r\n    callback: (\r\n      dataUrl: string | ArrayBuffer,\r\n      type: string,\r\n      name?: string\r\n    ) => void,\r\n    e: ClipboardEvent | DragEvent\r\n  ): void {\r\n    const { type, name = '' } = file\r\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\r\n      e.preventDefault()\r\n      const reader = new FileReader()\r\n      reader.onload = (e: ProgressEvent<FileReader>) => {\r\n        if (e.target && e.target.result) {\r\n          callback(e.target.result, type, name)\r\n        }\r\n      }\r\n      reader.readAsDataURL(file)\r\n    }\r\n  }\r\n\r\n  /* insert into the editor\r\n   */\r\n  insert(content: string, type: string, index?: number): void {\r\n    index = index === undefined ? this.getIndex() : index\r\n    let _index: any\r\n    if (type === 'image') {\r\n      _index = index + 1\r\n      this.quill.insertEmbed(index, type, content, 'user')\r\n    } else if (type === 'text') {\r\n      _index = index + content.length\r\n      this.quill.insertText(index, content, 'user')\r\n    }\r\n    setTimeout(() => {\r\n      this.quill.setSelection(_index)\r\n    })\r\n  }\r\n\r\n  getIndex(): number {\r\n    let index: number | undefined = (this.quill.getSelection(true) || {}).index\r\n    if (index === undefined || index < 0) index = this.quill.getLength()\r\n    return index\r\n  }\r\n}\r\n\r\n;(window as any).QuillImageDropAndPaste = ImageDropAndPaste\r\nif ('Quill' in window) {\r\n  ;(window as any).Quill.register(\r\n    'modules/imageDropAndPaste',\r\n    ImageDropAndPaste\r\n  )\r\n}\r\n\r\nexport default ImageDropAndPaste\r\n"],"names":["utils","generateFilename","btoa","String","Math","random","Date","replace","urlIsImage","url","abortTimeout","this","validURL","test","Promise","resolve","reject","timer","img","Image","onerror","onabort","clearTimeout","onload","setTimeout","src","urlIsImageDataUrl","str","Boolean","URL","e","isRichText","clipboardDataItems","hasHtml","hasImage","Array","prototype","forEach","call","item","console","log","kind","type","match","resolveDataUrl","dataUrl","ArrayBuffer","arrayBufferToBase64Url","binaryStringToArrayBuffer","binary","len","length","buffer","arr","Uint8Array","i","charCodeAt","arrayBuffer","reduce","acc","byte","fromCharCode","copyText","content","target","document","body","element","createElement","previouslyFocusedElement","activeElement","value","setAttribute","style","position","left","fontSize","selection","getSelection","originalRange","rangeCount","getRangeAt","append","select","selectionStart","selectionEnd","isSuccess","execCommand","_a","remove","removeAllRanges","addRange","focus","isType","Object","toString","QuillImageData","constructor","name","ImageData","super","getSuffix","minify","option","maxWidth","maxHeight","quality","message","image","width","height","canvas","ctx","getContext","drawImage","canvasType","canvasDataUrl","toDataURL","toFile","filename","window","File","toBlob","error","base64","buff","atob","createBlob","parts","properties","Blob","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","getBlob","matched","QuillImageDropAndPaste","quill","ImageDropAndPaste","handleDrop","bind","handlePaste","insert","root","addEventListener","dataTransfer","files","preventDefault","caretRangeFromPoint","range","clientX","clientY","setBaseAndExtent","startContainer","startOffset","readFiles","handler","clipboardData","items","callback","file","handleDataTransfer","handleDroppedFile","that","reader","FileReader","result","blob","getAsFile","readAsDataURL","getAsString","s","disable","getIndex","then","t","enable","setSelection","catch","index","_index","undefined","insertEmbed","insertText","getLength","Quill","register"],"mappings":"AAAA,IAAeA,EAAA,CAGbC,iBAAgB,IACPC,KAAKC,OAAuB,IAAhBC,KAAKC,UAAkBF,QAAQ,IAAIG,OAASC,QAC7D,IACA,IAKJC,WAAWC,EAAaC,EAAe,KACrC,OAAKC,KAAKC,SAASH,GAGf,sCAAsCI,KAAKJ,GACtCK,QAAQC,SAAQ,GAElB,IAAID,SAAQ,CAACC,EAASC,KAC3B,IAAIC,EACJ,MAAMC,EAAM,IAAIC,MAChBD,EAAIE,QAAUF,EAAIG,QAAU,KAC1BC,aAAaL,GACbD,GAAO,EAAM,EAEfE,EAAIK,OAAS,KACXD,aAAaL,GACbF,GAAQ,EAAK,EAEfE,EAAQO,YAAW,KACjBN,EAAIO,IAAM,qBACVT,GAAO,EAAM,GACZN,GACHQ,EAAIO,IAAMhB,CAAG,IApBNK,QAAQE,QAAO,EAsBzB,EACDU,kBAAkBjB,GACT,2BAA2BI,KAAKJ,GAIzCG,SAASe,GACP,IACE,OAAOC,QAAQ,IAAIC,IAAIF,GAGxB,CAFC,MAAOG,GACP,OAAO,CACR,CACF,EAGDC,WAAWC,GACT,IAAIC,GAAU,EACVC,GAAW,EAUf,OATAC,MAAMC,UAAUC,QAAQC,KAAKN,GAAqBO,IAChDC,QAAQC,IAAIF,EAAKG,KAAMH,EAAKI,MACV,WAAdJ,EAAKG,MAAqBH,EAAKI,KAAKC,MAAM,mBAC5CX,GAAU,GAEM,SAAdM,EAAKG,MAAmBH,EAAKI,KAAKC,MAAM,mBAC1CV,GAAW,EACZ,IAEID,IAAYC,CACpB,EAGDW,eAAeC,EAA+BH,GAC5C,IAAIhB,EAAM,GAMV,MALuB,iBAAZmB,EACTnB,EAAMmB,EACGA,aAAmBC,cAC5BpB,EAAMhB,KAAKqC,uBAAuBF,EAASH,IAEtChB,CACR,EAGDsB,0BAA0BC,GACxB,MAAMC,EAAMD,EAAOE,OACbC,EAAS,IAAIN,YAAYI,GACzBG,EAAM,IAAIC,WAAWF,GAC3B,IAAIG,GAAK,EACT,OAASA,EAAIL,GAAKG,EAAIE,GAAKN,EAAOO,WAAWD,GAC7C,OAAOH,CACR,EAGDL,uBAAsB,CAACU,EAA0Bf,IAE7C,QAAQA,YACRzC,KACE,IAAIqD,WAAWG,GAAaC,QAC1B,CAACC,EAAaC,IAAiBD,EAAMzD,OAAO2D,aAAaD,IACzD,KAORE,SAASC,EAAiBC,EAASC,SAASC,MAC1C,MAAMC,EAAUF,SAASG,cAAc,YACjCC,EAA2BJ,SAASK,cAC1CH,EAAQI,MAAQR,EAEhBI,EAAQK,aAAa,WAAY,IACjCL,EAAQM,MAAMC,SAAW,WACzBP,EAAQM,MAAME,KAAO,UACrBR,EAAQM,MAAMG,SAAW,OACzB,MAAMC,EAAYZ,SAASa,eAC3B,IAAIC,GAAiC,EACjCF,GAAaA,EAAUG,WAAa,IACtCD,EAAgBF,EAAUI,WAAW,IAEvCjB,EAAOkB,OAAOf,GACdA,EAAQgB,SAERhB,EAAQiB,eAAiB,EACzBjB,EAAQkB,aAAetB,EAAQZ,OAC/B,IAAImC,GAAY,EAChB,IACEA,EAAYrB,SAASsB,YAAY,OAEzB,CAAR,MAAAC,GAAQ,CAUV,OATArB,EAAQsB,SACJZ,GAAaE,IACfF,EAAUa,kBACVb,EAAUc,SAASZ,IAGjBV,GACAA,EAAyCuB,QAEtCN,CACR,EAGDO,OAAM,CAAC7B,EAAatB,IACXoD,OAAO3D,UAAU4D,SAAS1D,KAAK2B,KAAY,WAAWtB,MCvIjE,MAAesD,EAIbC,YACEpD,EACAH,EACAwD,GAEAxF,KAAKmC,QAAUA,EACfnC,KAAKgC,KAAOA,EACZhC,KAAKwF,KAAOA,GAAQ,EACrB,EAMH,MAAMC,UAAkBH,EAKtBC,YAAYpD,EAA+BH,EAAcwD,GACvDE,MAAMvD,EAASH,EAAMwD,GACrBxF,KAAKmC,QAAUA,EACfnC,KAAKgC,KAAOA,EACZhC,KAAKwF,KAAOA,GAAQ,GAAGnG,EAAMC,sBAAsBU,KAAK2F,aACzD,CAIMC,OACLC,GAEA,OAAO,IAAI1F,SAAQ,CAACC,EAASC,KAC3B,MAAMyF,EAAWD,EAAOC,UAAY,IAC9BC,EAAYF,EAAOE,WAAa,IAChCC,EAAUH,EAAOG,SAAW,GAClC,IAAKhG,KAAKmC,QACR,OAAO9B,EAAO,CACZ4F,QACE,2FAGN,MAAMC,EAAQ,IAAI1F,MAClB0F,EAAMtF,OAAS,KACb,MAAMuF,EAAQD,EAAMC,MACdC,EAASF,EAAME,OACjBD,EAAQC,EACND,EAAQL,IACVI,EAAME,OAAUA,EAASN,EAAYK,EACrCD,EAAMC,MAAQL,GAGZM,EAASL,IACXG,EAAMC,MAASA,EAAQJ,EAAaK,EACpCF,EAAME,OAASL,GAGnB,MAAMM,EAAS9C,SAASG,cAAc,UACtC2C,EAAOF,MAAQD,EAAMC,MACrBE,EAAOD,OAASF,EAAME,OACtB,MAAME,EAAMD,EAAOE,WAAW,MAC9B,GAAID,EAAK,CACPA,EAAIE,UAAUN,EAAO,EAAG,EAAGA,EAAMC,MAAOD,EAAME,QAC9C,MAAMK,EAAazG,KAAKgC,MAAQ,YAC1B0E,EAAgBL,EAAOM,UAAUF,EAAYT,GACnD5F,EAAQ,IAAIqF,EAAUiB,EAAeD,EAAYzG,KAAKwF,MACvD,MACCnF,EAAO,CACL4F,QACE,4FAEL,EAEHC,EAAMpF,IAAMzB,EAAM6C,eAAelC,KAAKmC,QAASnC,KAAKgC,KAAK,GAE5D,CAIM4E,OAAOC,GAEZ,OADAA,EAAWA,GAAY7G,KAAKwF,KACvBsB,OAAOC,KAML,IAAIA,KAAK,CAAC/G,KAAKgH,UAAWH,EAAU,CAAE7E,KAAMhC,KAAKgC,QALtDH,QAAQoF,MACN,yEAEK,KAGV,CAIMD,SACL,MAAME,EAAS7H,EACZ6C,eAAelC,KAAKmC,QAASnC,KAAKgC,MAClCpC,QAAQ,UAAW,IAChBuH,EAAO9H,EAAMiD,0BAA0B8E,KAAKF,IAClD,OAAOlH,KAAKqH,WAAW,CAACF,GAAO,CAAEnF,KAAMhC,KAAKgC,MAC7C,CAIOqF,WACNC,EACAC,GAEKA,IAAYA,EAAa,CAAA,GACJ,iBAAfA,IAAyBA,EAAa,CAAEvF,KAAMuF,IACzD,IACE,OAAO,IAAIC,KAAKF,EAAOC,EAcxB,CAbC,MAAOpG,GACP,GAAe,cAAXA,EAAEqE,KAAsB,MAAMrE,EAClC,MAQMsG,EAAU,IAPd,gBAAiBX,OACZA,OAAeY,YAChB,kBAAmBZ,OAClBA,OAAea,cAChB,mBAAoBb,OACnBA,OAAec,eACfd,OAAee,mBAEtB,IAAK,IAAIhF,EAAI,EAAGA,EAAIyE,EAAM7E,OAAQI,IAAK4E,EAAQjD,OAAO8C,EAAMzE,IAC5D,OAAO4E,EAAQK,QAAQP,EAAWvF,KACnC,CACF,CAEO2D,YACN,MAAMoC,EAAU/H,KAAKgC,KAAKC,MAAM,kBAEhC,OADe8F,EAAUA,EAAQ,GAAK,KAEvC,EC7HH,MAAeC,EAIbzC,YAAmB0C,EAAcpC,GAC/B7F,KAAKiI,MAAQA,EACbjI,KAAK6F,OAASA,CACf,EAsBH,MAAMqC,UAA0BF,EAK9BzC,YAAY0C,EAAcpC,GACxBH,MAAMuC,EAAOpC,GACb7F,KAAKiI,MAAQA,EACbjI,KAAK6F,OAASA,EACd7F,KAAKmI,WAAanI,KAAKmI,WAAWC,KAAKpI,MACvCA,KAAKqI,YAAcrI,KAAKqI,YAAYD,KAAKpI,MACzCA,KAAKsI,OAAStI,KAAKsI,OAAOF,KAAKpI,MAC/BA,KAAKiI,MAAMM,KAAKC,iBAAiB,OAAQxI,KAAKmI,YAAY,GAC1DnI,KAAKiI,MAAMM,KAAKC,iBAAiB,QAASxI,KAAKqI,aAAa,EAC7D,CAIDF,WAAWhH,GACT,GAAIA,EAAEsH,cAAgBtH,EAAEsH,aAAaC,OAASvH,EAAEsH,aAAaC,MAAMjG,OAAQ,CAEzE,GADAtB,EAAEwH,iBACEpF,SAASqF,oBAAqB,CAChC,MAAMzE,EAAYZ,SAASa,eACrByE,EAAQtF,SAASqF,oBAAoBzH,EAAE2H,QAAS3H,EAAE4H,SACpD5E,GAAa0E,GACf1E,EAAU6E,iBACRH,EAAMI,eACNJ,EAAMK,YACNL,EAAMI,eACNJ,EAAMK,YAGX,CACDlJ,KAAKmJ,UACHhI,EAAEsH,aAAaC,OACf,CAACvG,EAA+BH,EAAO,YAAawD,KACf,mBAAxBxF,KAAK6F,OAAOuD,QACrBpJ,KAAK6F,OAAOuD,QAAQzH,KAClB3B,KACAmC,EACAH,EACA,IAAIyD,EAAUtD,EAASH,EAAMwD,IAG/BxF,KAAKsI,OAAO3G,KAAK3B,KAAMX,EAAM6C,eAAeC,EAASH,GAAOA,EAC7D,GAEHb,EAEH,CACF,CAIDkH,YAAYlH,GACV,GACEA,EAAEkI,eACFlI,EAAEkI,cAAcC,OAChBnI,EAAEkI,cAAcC,MAAM7G,OACtB,CACA,GAAIpD,EAAM+B,WAAWD,EAAEkI,cAAcC,OAAQ,OAC7CtJ,KAAKmJ,UACHhI,EAAEkI,cAAcC,OAChB,CAACnH,EAA+BH,EAAO,eACF,mBAAxBhC,KAAK6F,OAAOuD,QACrBpJ,KAAK6F,OAAOuD,QAAQzH,KAClB3B,KACAmC,EACAH,EACA,IAAIyD,EAAUtD,EAASH,IAGzBhC,KAAKsI,OAAOjJ,EAAM6C,eAAeC,EAASH,GAAO,QAClD,GAEHb,EAEH,CACF,CAIDgI,UACET,EACAa,EAKApI,GAEAK,MAAMC,UAAUC,QAAQC,KAAK+G,GAAQc,IAC/BnK,EAAM8F,OAAOqE,EAAM,oBACrBxJ,KAAKyJ,mBAAmBD,EAA0BD,EAAUpI,GACnDqI,aAAgBzC,MACzB/G,KAAK0J,kBAAkBF,EAAMD,EAAUpI,EACxC,GAEJ,CAIDsI,mBACED,EACAD,EAKApI,GAEA,MAAMwI,EAAO3J,MACPgC,KAAEA,GAASwH,EACjB,GAAIxH,EAAKC,MAAM,2CAA4C,CACzDd,EAAEwH,iBACF,MAAMiB,EAAS,IAAIC,WACnBD,EAAOhJ,OAAUO,IACXA,EAAEmC,QAAUnC,EAAEmC,OAAOwG,QACvBP,EAASpI,EAAEmC,OAAOwG,OAAQ9H,EAC3B,EAEH,MAAM+H,EAAOP,EAAKQ,UAAYR,EAAKQ,YAAcR,EAC7CO,aAAgBvC,MAAMoC,EAAOK,cAAcF,EAChD,MAAU/H,EAAKC,MAAM,mBACpBuH,EAAKU,aAAaC,IAGhBnK,KAAKiI,MAAMmC,UACX,MAAMvH,EAAI7C,KAAKqK,WACfhL,EACGQ,WAAWsK,GACXG,MAAK,KAEJ,GAAIjL,EAAM0B,kBAAkBoJ,GAAI,CAE9B,MAAMpC,EAAUoC,EAAElI,MAAM,8BAClBsI,EAAIxC,EAAUA,EAAQ,GAAK,YACjCwB,EAASY,EAAGI,GACZvK,KAAKiI,MAAMuC,SACXxK,KAAKiI,MAAMwC,aAAa5H,EACzB,MAEChC,YAAW,KACTb,KAAKiI,MAAMuC,SACXb,EAAKrB,OAAO6B,EAAG,QAAStH,EAAE,GAE7B,IAEF6H,OAAM,KACL1K,KAAKiI,MAAMuC,QAAQ,GACnB,GAGT,CAIDd,kBACEF,EACAD,EAKApI,GAEA,MAAMa,KAAEA,EAAIwD,KAAEA,EAAO,IAAOgE,EAC5B,GAAIxH,EAAKC,MAAM,2CAA4C,CACzDd,EAAEwH,iBACF,MAAMiB,EAAS,IAAIC,WACnBD,EAAOhJ,OAAUO,IACXA,EAAEmC,QAAUnC,EAAEmC,OAAOwG,QACvBP,EAASpI,EAAEmC,OAAOwG,OAAQ9H,EAAMwD,EACjC,EAEHoE,EAAOK,cAAcT,EACtB,CACF,CAIDlB,OAAOjF,EAAiBrB,EAAc2I,GAEpC,IAAIC,EADJD,OAAkBE,IAAVF,EAAsB3K,KAAKqK,WAAaM,EAEnC,UAAT3I,GACF4I,EAASD,EAAQ,EACjB3K,KAAKiI,MAAM6C,YAAYH,EAAO3I,EAAMqB,EAAS,SAC3B,SAATrB,IACT4I,EAASD,EAAQtH,EAAQZ,OACzBzC,KAAKiI,MAAM8C,WAAWJ,EAAOtH,EAAS,SAExCxC,YAAW,KACTb,KAAKiI,MAAMwC,aAAaG,EAAO,GAElC,CAEDP,WACE,IAAIM,GAA6B3K,KAAKiI,MAAM7D,cAAa,IAAS,CAAE,GAAEuG,MAEtE,YADcE,IAAVF,GAAuBA,EAAQ,KAAGA,EAAQ3K,KAAKiI,MAAM+C,aAClDL,CACR,EAvMMzC,EAASzC,UAAGA,EA0MnBqB,OAAekB,uBAAyBE,EACtC,UAAWpB,QACXA,OAAemE,MAAMC,SACrB,4BACAhD"}