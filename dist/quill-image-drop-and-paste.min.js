'use strict';
Object.defineProperty(exports, '__esModule', { value: !0 });
var e = {
  urlIsImage(e, t = 3e3) {
    return this.validURL(e)
      ? /\.(jpeg|jpg|gif|png|webp|tiff|bmp)$/.test(e)
        ? Promise.resolve(!0)
        : new Promise((i, r) => {
            let a;
            const n = new Image();
            (n.onerror = n.onabort =
              () => {
                clearTimeout(a), r(!1);
              }),
              (n.onload = () => {
                clearTimeout(a), i(!0);
              }),
              (a = setTimeout(() => {
                (n.src = '//!/an/invalid.jpg'), r(!1);
              }, t)),
              (n.src = e);
          })
      : Promise.reject(!1);
  },
  validURL(e) {
    try {
      return Boolean(new URL(e));
    } catch (e) {
      return !1;
    }
  },
  isHtmlText(e) {
    let t = !1;
    return (
      Array.prototype.forEach.call(e, (e) => {
        e.type.match(/^text\/html$/i) && (t = !0);
      }),
      t
    );
  },
  resolveDataUrl(e) {
    let t = '';
    return 'string' == typeof e ? (t = e) : e instanceof ArrayBuffer && (t = this.arrayBufferToBase64Url(e)), t;
  },
  binaryStringToArrayBuffer(e) {
    const t = e.length,
      i = new ArrayBuffer(t),
      r = new Uint8Array(i);
    let a = -1;
    for (; ++a < t; ) r[a] = e.charCodeAt(a);
    return i;
  },
  arrayBufferToBase64Url: (e) => btoa(String.fromCharCode(...new Uint8Array(e))),
};
class t {
  constructor(e, t) {
    (this.dataUrl = e), (this.type = t);
  }
  minify(i) {
    return new Promise((r, a) => {
      const n = i.maxWidth || 800,
        o = i.maxHeight || 800,
        s = i.quality || 0.8;
      if (!this.dataUrl)
        return a({ message: '[error] QuillImageDropAndPaste: Fail to minify the image, dataUrl should not be empty.' });
      const l = new Image();
      (l.onload = () => {
        const e = l.width,
          i = l.height;
        e > i ? e > n && ((l.height = (i * n) / e), (l.width = n)) : i > o && ((l.width = (e * o) / i), (l.height = o));
        const h = document.createElement('canvas');
        (h.width = l.width), (h.height = l.height);
        const d = h.getContext('2d');
        if (d) {
          d.drawImage(l, 0, 0, l.width, l.height);
          const e = this.type || 'image/png',
            i = h.toDataURL(e, s);
          r(new t(i, e));
        } else
          a({ message: '[error] QuillImageDropAndPaste: Fail to minify the image, create canvas context failure.' });
      }),
        (l.src = e.resolveDataUrl(this.dataUrl));
    });
  }
  toFile(e) {
    return window.File
      ? new File([this.toBlob()], e, { type: this.type })
      : (console.error('[error] QuillImageDropAndPaste: Your browser didnot support File API.'), null);
  }
  toBlob() {
    const t = e.resolveDataUrl(this.dataUrl).replace(/^[^,]+,/, ''),
      i = e.binaryStringToArrayBuffer(atob(t));
    return this.createBlob([i], { type: this.type });
  }
  createBlob(e, t) {
    t || (t = {}), 'string' == typeof t && (t = { type: t });
    try {
      return new Blob(e, t);
    } catch (i) {
      if ('TypeError' !== i.name) throw i;
      const r = new (
        'BlobBuilder' in window
          ? window.BlobBuilder
          : 'MSBlobBuilder' in window
          ? window.MSBlobBuilder
          : 'MozBlobBuilder' in window
          ? window.MozBlobBuilder
          : window.WebKitBlobBuilder
      )();
      for (let t = 0; t < e.length; t++) r.append(e[t]);
      return r.getBlob(t.type);
    }
  }
}
class i {
  constructor(e, t) {
    (this.quill = e),
      (this.option = t),
      (this.handleDrop = this.handleDrop.bind(this)),
      (this.handlePaste = this.handlePaste.bind(this)),
      (this.insert = this.insert.bind(this)),
      this.quill.root.addEventListener('drop', this.handleDrop, !1),
      this.quill.root.addEventListener('paste', this.handlePaste, !1);
  }
  handleDrop(i) {
    if ((i.preventDefault(), i.dataTransfer && i.dataTransfer.files && i.dataTransfer.files.length)) {
      if (document.caretRangeFromPoint) {
        const e = document.getSelection(),
          t = document.caretRangeFromPoint(i.clientX, i.clientY);
        e && t && e.setBaseAndExtent(t.startContainer, t.startOffset, t.startContainer, t.startOffset);
      }
      this.readFiles(
        i.dataTransfer.files,
        (i, r) => {
          (r = r || 'image/png'),
            'function' == typeof this.option.handler
              ? this.option.handler.call(this, i, r, new t(i, r))
              : this.insert.call(this, e.resolveDataUrl(i), r);
        },
        i,
      );
    }
  }
  handlePaste(i) {
    if (i.clipboardData && i.clipboardData.items && i.clipboardData.items.length) {
      if (e.isHtmlText(i.clipboardData.items)) return;
      this.readFiles(
        i.clipboardData.items,
        (i, r) => {
          (r = r || 'image/png'),
            'function' == typeof this.option.handler
              ? this.option.handler.call(this, i, r, new t(i, r))
              : this.insert(e.resolveDataUrl(i), 'image');
        },
        i,
      );
    }
  }
  readFiles(t, i, r) {
    r.preventDefault();
    const a = this;
    Array.prototype.forEach.call(t, (t) => {
      const r = t.type;
      if (r.match(/^image\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {
        const e = new FileReader();
        e.onload = (e) => {
          e.target && e.target.result && i(e.target.result, r);
        };
        const a = t.getAsFile ? t.getAsFile() : t;
        a instanceof Blob && e.readAsDataURL(a);
      } else
        r.match(/^text\/plain$/i) &&
          t.getAsString((t) => {
            e.urlIsImage(t)
              .then(() => {
                a.insert(t, 'image');
              })
              .catch(() => {
                a.insert(t, 'text');
              });
          });
    });
  }
  insert(e, t) {
    let i = (this.quill.getSelection(!0) || {}).index;
    if (((void 0 === i || i < 0) && (i = this.quill.getLength()), 'image' === t)) {
      const r = i + 1;
      this.quill.insertEmbed(i, t, e, 'user'), this.quill.setSelection(r);
    } else if ('text' === t) {
      const t = i + e.length;
      this.quill.insertText(i, e, 'user'), this.quill.setSelection(t);
    }
  }
}
(i.ImageData = t),
  (window.QuillImageDropAndPaste = i),
  'Quill' in window && window.Quill.register('modules/imageDropAndPaste', i),
  (exports.ImageData = t),
  (exports.default = i);
//# sourceMappingURL=quill-image-drop-and-paste.min.js.map
