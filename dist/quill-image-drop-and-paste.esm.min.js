var t = {
  urlIsImage(t, e = 3e3) {
    return this.validURL(t)
      ? /\.(jpeg|jpg|gif|png|webp|tiff|bmp)$/.test(t)
        ? Promise.resolve(!0)
        : new Promise((i, r) => {
            let a;
            const n = new Image();
            (n.onerror = n.onabort =
              () => {
                clearTimeout(a), r(!1);
              }),
              (n.onload = () => {
                clearTimeout(a), i(!0);
              }),
              (a = setTimeout(() => {
                (n.src = '//!/an/invalid.jpg'), r(!1);
              }, e)),
              (n.src = t);
          })
      : Promise.reject(!1);
  },
  validURL(t) {
    try {
      return Boolean(new URL(t));
    } catch (t) {
      return !1;
    }
  },
  isHtmlText(t) {
    let e = !1;
    return (
      Array.prototype.forEach.call(t, (t) => {
        t.type.match(/^text\/html$/i) && (e = !0);
      }),
      e
    );
  },
  resolveDataUrl(t) {
    let e = '';
    return 'string' == typeof t ? (e = t) : t instanceof ArrayBuffer && (e = this.arrayBufferToBase64Url(t)), e;
  },
  binaryStringToArrayBuffer(t) {
    const e = t.length,
      i = new ArrayBuffer(e),
      r = new Uint8Array(i);
    let a = -1;
    for (; ++a < e; ) r[a] = t.charCodeAt(a);
    return i;
  },
  arrayBufferToBase64Url: (t) => btoa(String.fromCharCode(...new Uint8Array(t))),
};
class e {
  constructor(t, e) {
    (this.dataUrl = t), (this.type = e);
  }
  minify(i) {
    return new Promise((r, a) => {
      const n = i.maxWidth || 800,
        o = i.maxHeight || 800,
        s = i.quality || 0.8;
      if (!this.dataUrl)
        return a({ message: '[error] QuillImageDropAndPaste: Fail to minify the image, dataUrl should not be empty.' });
      const l = new Image();
      (l.onload = () => {
        const t = l.width,
          i = l.height;
        t > i ? t > n && ((l.height = (i * n) / t), (l.width = n)) : i > o && ((l.width = (t * o) / i), (l.height = o));
        const h = document.createElement('canvas');
        (h.width = l.width), (h.height = l.height);
        const d = h.getContext('2d');
        if (d) {
          d.drawImage(l, 0, 0, l.width, l.height);
          const t = this.type || 'image/png',
            i = h.toDataURL(t, s);
          r(new e(i, t));
        } else
          a({ message: '[error] QuillImageDropAndPaste: Fail to minify the image, create canvas context failure.' });
      }),
        (l.src = t.resolveDataUrl(this.dataUrl));
    });
  }
  toFile(t) {
    return window.File
      ? new File([this.toBlob()], t, { type: this.type })
      : (console.error('[error] QuillImageDropAndPaste: Your browser didnot support File API.'), null);
  }
  toBlob() {
    const e = t.resolveDataUrl(this.dataUrl).replace(/^[^,]+,/, ''),
      i = t.binaryStringToArrayBuffer(atob(e));
    return this.createBlob([i], { type: this.type });
  }
  createBlob(t, e) {
    e || (e = {}), 'string' == typeof e && (e = { type: e });
    try {
      return new Blob(t, e);
    } catch (i) {
      if ('TypeError' !== i.name) throw i;
      const r = new (
        'BlobBuilder' in window
          ? window.BlobBuilder
          : 'MSBlobBuilder' in window
          ? window.MSBlobBuilder
          : 'MozBlobBuilder' in window
          ? window.MozBlobBuilder
          : window.WebKitBlobBuilder
      )();
      for (let e = 0; e < t.length; e++) r.append(t[e]);
      return r.getBlob(e.type);
    }
  }
}
class i {
  constructor(t, e) {
    (this.quill = t),
      (this.option = e),
      (this.handleDrop = this.handleDrop.bind(this)),
      (this.handlePaste = this.handlePaste.bind(this)),
      (this.insert = this.insert.bind(this)),
      this.quill.root.addEventListener('drop', this.handleDrop, !1),
      this.quill.root.addEventListener('paste', this.handlePaste, !1);
  }
  handleDrop(i) {
    if ((i.preventDefault(), i.dataTransfer && i.dataTransfer.files && i.dataTransfer.files.length)) {
      if (document.caretRangeFromPoint) {
        const t = document.getSelection(),
          e = document.caretRangeFromPoint(i.clientX, i.clientY);
        t && e && t.setBaseAndExtent(e.startContainer, e.startOffset, e.startContainer, e.startOffset);
      }
      this.readFiles(
        i.dataTransfer.files,
        (i, r) => {
          (r = r || 'image/png'),
            'function' == typeof this.option.handler
              ? this.option.handler.call(this, i, r, new e(i, r))
              : this.insert.call(this, t.resolveDataUrl(i), r);
        },
        i,
      );
    }
  }
  handlePaste(i) {
    if (i.clipboardData && i.clipboardData.items && i.clipboardData.items.length) {
      if (t.isHtmlText(i.clipboardData.items)) return;
      this.readFiles(
        i.clipboardData.items,
        (i, r) => {
          (r = r || 'image/png'),
            'function' == typeof this.option.handler
              ? this.option.handler.call(this, i, r, new e(i, r))
              : this.insert(t.resolveDataUrl(i), 'image');
        },
        i,
      );
    }
  }
  readFiles(e, i, r) {
    r.preventDefault();
    const a = this;
    Array.prototype.forEach.call(e, (e) => {
      const r = e.type;
      if (r.match(/^image\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {
        const t = new FileReader();
        t.onload = (t) => {
          t.target && t.target.result && i(t.target.result, r);
        };
        const a = e.getAsFile ? e.getAsFile() : e;
        a instanceof Blob && t.readAsDataURL(a);
      } else
        r.match(/^text\/plain$/i) &&
          e.getAsString((e) => {
            t.urlIsImage(e)
              .then(() => {
                a.insert(e, 'image');
              })
              .catch(() => {
                a.insert(e, 'text');
              });
          });
    });
  }
  insert(t, e) {
    let i = (this.quill.getSelection(!0) || {}).index;
    if (((void 0 === i || i < 0) && (i = this.quill.getLength()), 'image' === e)) {
      const r = i + 1;
      this.quill.insertEmbed(i, e, t, 'user'), this.quill.setSelection(r);
    } else if ('text' === e) {
      const e = i + t.length;
      this.quill.insertText(i, t, 'user'), this.quill.setSelection(e);
    }
  }
}
(i.ImageData = e),
  (window.QuillImageDropAndPaste = i),
  'Quill' in window && window.Quill.register('modules/imageDropAndPaste', i);
export { e as ImageData, i as default };
//# sourceMappingURL=quill-image-drop-and-paste.esm.min.js.map
