{"version":3,"file":"quill-image-drop-and-paste.cjs.min.js","sources":["../src/utils.ts","../src/ImageData.ts","../src/ImageDropAndPaste.ts"],"sourcesContent":["export default {\r\n  /* generate a filename\r\n   */\r\n  generateFilename(): string {\r\n    return btoa(String(Math.random() * 1e6) + String(+new Date())).replace('=', '');\r\n  },\r\n  /* detect the giving url is a image\r\n   */\r\n  urlIsImage(url: string, abortTimeout = 3000): Promise<boolean> {\r\n    if (!this.validURL(url)) {\r\n      return Promise.reject(false);\r\n    }\r\n    if (/\\.(jpeg|jpg|gif|png|webp|tiff|bmp)$/.test(url)) {\r\n      return Promise.resolve(true);\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      let timer: any = undefined;\r\n      const img = new Image();\r\n      img.onerror = img.onabort = () => {\r\n        clearTimeout(timer);\r\n        reject(false);\r\n      };\r\n      img.onload = () => {\r\n        clearTimeout(timer);\r\n        resolve(true);\r\n      };\r\n      timer = setTimeout(() => {\r\n        img.src = '//!/an/invalid.jpg';\r\n        reject(false);\r\n      }, abortTimeout);\r\n      img.src = url;\r\n    });\r\n  },\r\n  /* check string is a valid url\r\n   */\r\n  validURL(str: string): boolean {\r\n    try {\r\n      return Boolean(new URL(str));\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  },\r\n  /* check the giving string is a html text\r\n   */\r\n  isRichText(clipboardDataItems: DataTransferItemList): boolean {\r\n    let isHtml = false;\r\n    Array.prototype.forEach.call(clipboardDataItems, (item) => {\r\n      if (item.type.match(/^text\\/html$/i)) {\r\n        isHtml = true;\r\n      }\r\n    });\r\n    return isHtml;\r\n  },\r\n  /* resolve dataUrl to base64 string\r\n   */\r\n  resolveDataUrl(dataUrl: string | ArrayBuffer, type: string): string {\r\n    let str = '';\r\n    if (typeof dataUrl === 'string') {\r\n      str = dataUrl;\r\n    } else if (dataUrl instanceof ArrayBuffer) {\r\n      str = this.arrayBufferToBase64Url(dataUrl, type);\r\n    }\r\n    return str;\r\n  },\r\n  /* generate array buffer from binary string\r\n   */\r\n  binaryStringToArrayBuffer(binary: string): ArrayBuffer {\r\n    const len = binary.length;\r\n    const buffer = new ArrayBuffer(len);\r\n    const arr = new Uint8Array(buffer);\r\n    let i = -1;\r\n    while (++i < len) arr[i] = binary.charCodeAt(i);\r\n    return buffer;\r\n  },\r\n  /* generate base64 string from array buffer\r\n   */\r\n  arrayBufferToBase64Url(arrayBuffer: ArrayBuffer, type: string): string {\r\n    return (\r\n      `data:${type};base64,` +\r\n      btoa(new Uint8Array(arrayBuffer).reduce((acc: string, byte: number) => acc + String.fromCharCode(byte), ''))\r\n    );\r\n  },\r\n  /* copy text - make text store in the clipboard\r\n   */\r\n  copyText(content: string, target = document.body): boolean {\r\n    const element = document.createElement('textarea');\r\n    const previouslyFocusedElement = document.activeElement;\r\n    element.value = content;\r\n    // Prevent keyboard from showing on mobile\r\n    element.setAttribute('readonly', '');\r\n    element.style.position = 'absolute';\r\n    element.style.left = '-9999px';\r\n    element.style.fontSize = '12pt'; // Prevent zooming on iOS\r\n    const selection = document.getSelection();\r\n    let originalRange: boolean | Range = false;\r\n    if (selection && selection.rangeCount > 0) {\r\n      originalRange = selection.getRangeAt(0);\r\n    }\r\n    target.append(element);\r\n    element.select();\r\n    // Explicit selection workaround for iOS\r\n    element.selectionStart = 0;\r\n    element.selectionEnd = content.length;\r\n    let isSuccess = false;\r\n    try {\r\n      isSuccess = document.execCommand('copy');\r\n    } catch {}\r\n    element.remove();\r\n    if (selection && originalRange) {\r\n      selection.removeAllRanges();\r\n      selection.addRange(originalRange);\r\n    }\r\n    // Get the focus back on the previously focused element, if any\r\n    if (previouslyFocusedElement) {\r\n      (previouslyFocusedElement as HTMLElement).focus();\r\n    }\r\n    return isSuccess;\r\n  },\r\n  /* check the type of specify target\r\n   */\r\n  isType(target: any, type: string): boolean {\r\n    return Object.prototype.toString.call(target) === `[object ${type}]`;\r\n  },\r\n};\r\n","import utils from './utils';\r\nimport { IImageDataMinifyOption } from './index.d';\r\n\r\nabstract class QuillImageData {\r\n  public dataUrl: string | ArrayBuffer;\r\n  public type: string;\r\n  public name: string;\r\n  public constructor(dataUrl: string | ArrayBuffer, type: string, name?: string) {\r\n    this.dataUrl = dataUrl;\r\n    this.type = type;\r\n    this.name = name || '';\r\n  }\r\n  public abstract minify(option: IImageDataMinifyOption);\r\n  public abstract toFile(filename?: string);\r\n  public abstract toBlob();\r\n}\r\n\r\nclass ImageData extends QuillImageData {\r\n  dataUrl: string | ArrayBuffer;\r\n  type: string;\r\n  name: string;\r\n\r\n  constructor(dataUrl: string | ArrayBuffer, type: string, name?: string) {\r\n    super(dataUrl, type, name);\r\n    this.dataUrl = dataUrl;\r\n    this.type = type;\r\n    this.name = name || `${utils.generateFilename()}.${this.getSuffix()}`;\r\n  }\r\n\r\n  /* minify the image\r\n   */\r\n  public minify(option: IImageDataMinifyOption): Promise<ImageData | { message: string }> {\r\n    return new Promise((resolve, reject) => {\r\n      const maxWidth = option.maxWidth || 800;\r\n      const maxHeight = option.maxHeight || 800;\r\n      const quality = option.quality || 0.8;\r\n      if (!this.dataUrl) {\r\n        return reject({\r\n          message: '[error] QuillImageDropAndPaste: Fail to minify the image, dataUrl should not be empty.',\r\n        });\r\n      }\r\n      const image = new Image();\r\n      image.onload = () => {\r\n        const width = image.width;\r\n        const height = image.height;\r\n        if (width > height) {\r\n          if (width > maxWidth) {\r\n            image.height = (height * maxWidth) / width;\r\n            image.width = maxWidth;\r\n          }\r\n        } else {\r\n          if (height > maxHeight) {\r\n            image.width = (width * maxHeight) / height;\r\n            image.height = maxHeight;\r\n          }\r\n        }\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = image.width;\r\n        canvas.height = image.height;\r\n        const ctx = canvas.getContext('2d');\r\n        if (ctx) {\r\n          ctx.drawImage(image, 0, 0, image.width, image.height);\r\n          const canvasType = this.type || 'image/png';\r\n          const canvasDataUrl = canvas.toDataURL(canvasType, quality);\r\n          resolve(new ImageData(canvasDataUrl, canvasType, this.name));\r\n        } else {\r\n          reject({\r\n            message: '[error] QuillImageDropAndPaste: Fail to minify the image, create canvas context failure.',\r\n          });\r\n        }\r\n      };\r\n      image.src = utils.resolveDataUrl(this.dataUrl, this.type);\r\n    });\r\n  }\r\n\r\n  /* convert blob to file\r\n   */\r\n  public toFile(filename?: string): File | null {\r\n    filename = filename || this.name;\r\n    if (!window.File) {\r\n      console.error('[error] QuillImageDropAndPaste: Your browser didnot support File API.');\r\n      return null;\r\n    }\r\n    return new File([this.toBlob()], filename, { type: this.type });\r\n  }\r\n\r\n  /* convert dataURL to blob\r\n   */\r\n  public toBlob(): Blob {\r\n    const base64 = utils.resolveDataUrl(this.dataUrl, this.type).replace(/^[^,]+,/, '');\r\n    const buff = utils.binaryStringToArrayBuffer(atob(base64));\r\n    return this.createBlob([buff], { type: this.type });\r\n  }\r\n\r\n  /* create blob\r\n   */\r\n  private createBlob(parts: ArrayBuffer[], properties: string | { type?: string } | undefined): Blob {\r\n    if (!properties) properties = {};\r\n    if (typeof properties === 'string') properties = { type: properties };\r\n    try {\r\n      return new Blob(parts, properties);\r\n    } catch (e: any) {\r\n      if (e.name !== 'TypeError') throw e;\r\n      const Builder =\r\n        'BlobBuilder' in window\r\n          ? (window as any).BlobBuilder\r\n          : 'MSBlobBuilder' in window\r\n          ? (window as any).MSBlobBuilder\r\n          : 'MozBlobBuilder' in window\r\n          ? (window as any).MozBlobBuilder\r\n          : (window as any).WebKitBlobBuilder;\r\n      const builder = new Builder();\r\n      for (let i = 0; i < parts.length; i++) builder.append(parts[i]);\r\n      return builder.getBlob(properties.type) as Blob;\r\n    }\r\n  }\r\n\r\n  private getSuffix(): string {\r\n    const matched = this.type.match(/^image\\/(\\w+)$/);\r\n    const suffix = matched ? matched[1] : 'png';\r\n    return suffix;\r\n  }\r\n}\r\n\r\nexport default ImageData;\r\n","import utils from './utils';\r\nimport Quill from 'quill';\r\nimport ImageData from './ImageData';\r\ninterface IImageDropAndPasteOption {\r\n  handler?: (dataUrl: string | ArrayBuffer, type?: string, imageData?: ImageData) => void;\r\n}\r\n\r\nabstract class QuillImageDropAndPaste {\r\n  static ImageData;\r\n  public quill;\r\n  public option: IImageDropAndPasteOption;\r\n  public constructor(quill: Quill, option: IImageDropAndPasteOption) {\r\n    this.quill = quill;\r\n    this.option = option;\r\n  }\r\n  protected abstract handleDrop(e: DragEvent);\r\n  protected abstract handlePaste(e: ClipboardEvent);\r\n  protected abstract readFiles(\r\n    files: DataTransferItemList | FileList,\r\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\r\n    e: ClipboardEvent | DragEvent,\r\n  );\r\n  protected abstract handleDataTransfer(\r\n    file: DataTransferItem,\r\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\r\n    e: ClipboardEvent | DragEvent,\r\n  );\r\n  protected abstract handleDroppedFile(\r\n    file: File,\r\n    callback: (dataUrl: string | ArrayBuffer, type?: string) => void,\r\n    e: ClipboardEvent | DragEvent,\r\n  );\r\n  protected abstract insert(content: string, type: string);\r\n  protected abstract getIndex();\r\n}\r\n\r\nclass ImageDropAndPaste extends QuillImageDropAndPaste {\r\n  static ImageData = ImageData;\r\n  quill: Quill;\r\n  option: IImageDropAndPasteOption;\r\n\r\n  constructor(quill: Quill, option: IImageDropAndPasteOption) {\r\n    super(quill, option);\r\n    this.quill = quill;\r\n    this.option = option;\r\n    this.handleDrop = this.handleDrop.bind(this);\r\n    this.handlePaste = this.handlePaste.bind(this);\r\n    this.insert = this.insert.bind(this);\r\n    this.quill.root.addEventListener('drop', this.handleDrop, false);\r\n    this.quill.root.addEventListener('paste', this.handlePaste, false);\r\n  }\r\n\r\n  /* handle image drop event\r\n   */\r\n  handleDrop(e: DragEvent): void {\r\n    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {\r\n      e.preventDefault();\r\n      if (document.caretRangeFromPoint) {\r\n        const selection = document.getSelection();\r\n        const range = document.caretRangeFromPoint(e.clientX, e.clientY);\r\n        if (selection && range) {\r\n          selection.setBaseAndExtent(range.startContainer, range.startOffset, range.startContainer, range.startOffset);\r\n        }\r\n      }\r\n      this.readFiles(\r\n        e.dataTransfer.files,\r\n        (dataUrl: string | ArrayBuffer, type = 'image/png', name?: string) => {\r\n          if (typeof this.option.handler === 'function') {\r\n            this.option.handler.call(this, dataUrl, type, new ImageData(dataUrl, type, name));\r\n          } else {\r\n            this.insert.call(this, utils.resolveDataUrl(dataUrl, type), type);\r\n          }\r\n        },\r\n        e,\r\n      );\r\n    }\r\n  }\r\n\r\n  /* handle image paste event\r\n   */\r\n  handlePaste(e: ClipboardEvent): void {\r\n    if (e.clipboardData && e.clipboardData.items && e.clipboardData.items.length) {\r\n      if (utils.isRichText(e.clipboardData.items)) return;\r\n      this.readFiles(\r\n        e.clipboardData.items,\r\n        (dataUrl: string | ArrayBuffer, type = 'image/png') => {\r\n          if (typeof this.option.handler === 'function') {\r\n            this.option.handler.call(this, dataUrl, type, new ImageData(dataUrl, type));\r\n          } else {\r\n            this.insert(utils.resolveDataUrl(dataUrl, type), 'image');\r\n          }\r\n        },\r\n        e,\r\n      );\r\n    }\r\n  }\r\n\r\n  /* read the files\r\n   */\r\n  readFiles(\r\n    files: DataTransferItemList | FileList,\r\n    callback: (dataUrl: string | ArrayBuffer, type: string, name?: string) => void,\r\n    e: ClipboardEvent | DragEvent,\r\n  ): void {\r\n    Array.prototype.forEach.call(files, (file: DataTransferItem | File) => {\r\n      if (utils.isType(file, 'DataTransferItem')) {\r\n        this.handleDataTransfer(file as DataTransferItem, callback, e);\r\n      } else if (file instanceof File) {\r\n        this.handleDroppedFile(file, callback, e);\r\n      }\r\n    });\r\n  }\r\n\r\n  /* handle the pasted data\r\n   */\r\n  handleDataTransfer(\r\n    file: DataTransferItem,\r\n    callback: (dataUrl: string | ArrayBuffer, type: string, name?: string) => void,\r\n    e: ClipboardEvent | DragEvent,\r\n  ): void {\r\n    const that = this;\r\n    const { type } = file;\r\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\r\n      e.preventDefault();\r\n      const reader = new FileReader();\r\n      reader.onload = (e: ProgressEvent<FileReader>) => {\r\n        if (e.target && e.target.result) {\r\n          callback(e.target.result, type);\r\n        }\r\n      };\r\n      const blob = file.getAsFile ? file.getAsFile() : file;\r\n      if (blob instanceof Blob) reader.readAsDataURL(blob);\r\n    } else if (type.match(/^text\\/plain$/i)) {\r\n      file.getAsString((s) => {\r\n        // Don't preventDefault here, because there might be clipboard matchers need to be triggered\r\n        // see https://github.com/chenjuneking/quill-image-drop-and-paste/issues/37\r\n        const i = this.getIndex();\r\n        utils\r\n          .urlIsImage(s)\r\n          .then(() => {\r\n            // If the pasted plain text is an image, delete the pasted text and insert the image\r\n            const j = this.getIndex();\r\n            this.quill.deleteText(i, j - i, 'user');\r\n            that.insert(s, 'image');\r\n          })\r\n          .catch(() => {\r\n            // Otherwise, do nothing\r\n          });\r\n      });\r\n    }\r\n  }\r\n\r\n  /* handle the dropped data\r\n   */\r\n  handleDroppedFile(\r\n    file: File,\r\n    callback: (dataUrl: string | ArrayBuffer, type: string, name?: string) => void,\r\n    e: ClipboardEvent | DragEvent,\r\n  ): void {\r\n    const { type, name = '' } = file;\r\n    if (type.match(/^image\\/(gif|jpe?g|a?png|svg|webp|bmp)/i)) {\r\n      e.preventDefault();\r\n      const reader = new FileReader();\r\n      reader.onload = (e: ProgressEvent<FileReader>) => {\r\n        if (e.target && e.target.result) {\r\n          callback(e.target.result, type, name);\r\n        }\r\n      };\r\n      reader.readAsDataURL(file);\r\n    }\r\n  }\r\n\r\n  /* insert into the editor\r\n   */\r\n  insert(content: string, type: string): void {\r\n    const index = this.getIndex();\r\n    let _index: any;\r\n    if (type === 'image') {\r\n      _index = index + 1;\r\n      this.quill.insertEmbed(index, type, content, 'user');\r\n    } else if (type === 'text') {\r\n      _index = index + content.length;\r\n      this.quill.insertText(index, content, 'user');\r\n    }\r\n    setTimeout(() => {\r\n      this.quill.setSelection(_index);\r\n    });\r\n  }\r\n\r\n  getIndex(): number {\r\n    let index: number | undefined = (this.quill.getSelection(true) || {}).index;\r\n    if (index === undefined || index < 0) index = this.quill.getLength();\r\n    return index;\r\n  }\r\n}\r\n\r\n(window as any).QuillImageDropAndPaste = ImageDropAndPaste;\r\nif ('Quill' in window) {\r\n  (window as any).Quill.register('modules/imageDropAndPaste', ImageDropAndPaste);\r\n}\r\n\r\nexport default ImageDropAndPaste;\r\n"],"names":["generateFilename","btoa","String","Math","random","Date","replace","urlIsImage","url","abortTimeout","this","validURL","test","Promise","resolve","reject","timer","img","Image","onerror","onabort","clearTimeout","onload","setTimeout","src","str","Boolean","URL","e","isRichText","clipboardDataItems","isHtml","Array","prototype","forEach","call","item","type","match","resolveDataUrl","dataUrl","ArrayBuffer","arrayBufferToBase64Url","binaryStringToArrayBuffer","binary","len","length","buffer","arr","Uint8Array","i","charCodeAt","arrayBuffer","reduce","acc","byte","fromCharCode","copyText","content","target","document","body","element","createElement","previouslyFocusedElement","activeElement","value","setAttribute","style","position","left","fontSize","selection","getSelection","originalRange","rangeCount","getRangeAt","append","select","selectionStart","selectionEnd","isSuccess","execCommand","remove","removeAllRanges","addRange","focus","isType","Object","toString","ImageData","constructor","name","super","utils","getSuffix","minify","option","maxWidth","maxHeight","quality","message","image","width","height","canvas","ctx","getContext","drawImage","canvasType","canvasDataUrl","toDataURL","toFile","filename","window","File","toBlob","console","error","base64","buff","atob","createBlob","parts","properties","Blob","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","getBlob","matched","ImageDropAndPaste","quill","handleDrop","bind","handlePaste","insert","root","addEventListener","dataTransfer","files","preventDefault","caretRangeFromPoint","range","clientX","clientY","setBaseAndExtent","startContainer","startOffset","readFiles","handler","clipboardData","items","callback","file","handleDataTransfer","handleDroppedFile","that","reader","FileReader","result","blob","getAsFile","readAsDataURL","getAsString","s","getIndex","then","j","deleteText","catch","index","_index","insertEmbed","insertText","setSelection","undefined","getLength","QuillImageDropAndPaste","Quill","register"],"mappings":"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"}